<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrightSpark AI - Diagnostic</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--tg-theme-bg-color, #2c3e50);
            color: var(--tg-theme-text-color, #ffffff);
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 16px;
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
        }

        .logo .bright { color: #ffffff; }
        .logo .spark { color: #FFC107; }
        .logo .lightning {
            color: #FFC107;
            font-size: 32px;
            margin: 0 8px;
            display: inline-block;
            animation: pulse 2s infinite;
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.8;
            color: #ecf0f1;
            font-weight: 300;
        }

        .diagnostic-card {
            background: rgba(52, 73, 94, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid rgba(255, 193, 7, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .test-section {
            margin-bottom: 20px;
            padding: 16px;
            background: rgba(44, 62, 80, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .test-title {
            font-size: 16px;
            font-weight: 600;
            color: #FFC107;
            margin-bottom: 12px;
        }

        .test-result {
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            max-height: 100px;
            overflow-y: auto;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            background: linear-gradient(45deg, #FFC107, #FFD54F);
            color: #2c3e50;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 8px;
            font-weight: 600;
        }

        .status.success {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border: 1px solid #2ecc71;
        }

        .status.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .status.testing {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
            border: 1px solid #f1c40f;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                <span class="bright">BRIGHT</span><span class="lightning">‚ö°</span><span class="spark">SPARK</span>
            </div>
            <div class="subtitle">Connection Diagnostics</div>
        </div>

        <div class="diagnostic-card">
            <h2 style="color: #FFC107; margin-bottom: 16px;">üîç Backend Connection Diagnostic</h2>
            
            <div class="test-section">
                <div class="test-title">1. HTTP Endpoints Test</div>
                <button class="btn" onclick="diagnostic.testHTTP()">Test HTTP Connections</button>
                <div class="test-result" id="httpResult">Click to test HTTP endpoints...</div>
                <div class="status testing" id="httpStatus">Ready to test</div>
            </div>

            <div class="test-section">
                <div class="test-title">2. WebSocket Connections Test</div>
                <button class="btn" onclick="diagnostic.testWebSockets()">Test WebSocket URLs</button>
                <div class="test-result" id="wsResult">Click to test WebSocket connections...</div>
                <div class="status testing" id="wsStatus">Ready to test</div>
            </div>

            <div class="test-section">
                <div class="test-title">3. Port-Specific Test</div>
                <button class="btn" onclick="diagnostic.testPorts()">Test Different Ports</button>
                <div class="test-result" id="portResult">Click to test various ports...</div>
                <div class="status testing" id="portStatus">Ready to test</div>
            </div>

            <div class="test-section">
                <div class="test-title">4. Working Connection</div>
                <button class="btn" onclick="diagnostic.useWorkingConnection()" id="useWorkingBtn" disabled>Use Working Connection</button>
                <div class="test-result" id="workingResult">Find working connection first...</div>
                <div class="status testing" id="workingStatus">No working connection found yet</div>
            </div>
        </div>
    </div>

    <script>
        class BrightSparkDiagnostic {
            constructor() {
                this.tg = window.Telegram?.WebApp;
                this.baseUrl = 'f65135a4-a630-48e1-b1bc-afae926f9770-00-3flnf1uw5vz2q.riker.replit.dev';
                this.workingConnection = null;
                this.init();
            }

            init() {
                if (this.tg) {
                    this.tg.ready();
                    this.tg.expand();
                    this.tg.setHeaderColor('#2c3e50');
                }
                
                console.log('üöÄ Diagnostic initialized');
            }

            updateResult(elementId, message) {
                document.getElementById(elementId).textContent = message;
            }

            updateStatus(elementId, message, type = 'testing') {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.className = `status ${type}`;
            }

            async testHTTP() {
                this.updateStatus('httpStatus', 'Testing HTTP endpoints...', 'testing');
                this.updateResult('httpResult', 'Starting HTTP tests...\n');
                
                const httpUrls = [
                    `https://${this.baseUrl}`,
                    `https://${this.baseUrl}/`,
                    `https://${this.baseUrl}:5000`,
                    `https://${this.baseUrl}:5000/`,
                    `http://${this.baseUrl}`,
                    `http://${this.baseUrl}:5000`
                ];

                let results = 'HTTP Test Results:\n\n';
                
                for (const url of httpUrls) {
                    try {
                        results += `Testing: ${url}\n`;
                        const response = await fetch(url, { 
                            method: 'GET',
                            timeout: 5000
                        });
                        
                        if (response.ok) {
                            const text = await response.text();
                            results += `‚úÖ SUCCESS (${response.status})\n`;
                            results += `Content: ${text.substring(0, 50)}...\n\n`;
                            
                            if (!this.workingConnection) {
                                this.workingConnection = url.replace('http://', '').replace('https://', '');
                                this.enableWorkingConnection();
                            }
                        } else {
                            results += `‚ùå FAILED (${response.status})\n\n`;
                        }
                    } catch (error) {
                        results += `‚ùå ERROR: ${error.message}\n\n`;
                    }
                    
                    this.updateResult('httpResult', results);
                }
                
                this.updateStatus('httpStatus', 'HTTP tests completed', 'success');
            }

            async testWebSockets() {
                this.updateStatus('wsStatus', 'Testing WebSocket connections...', 'testing');
                this.updateResult('wsResult', 'Starting WebSocket tests...\n');
                
                const wsUrls = [
                    `wss://${this.baseUrl}`,
                    `wss://${this.baseUrl}/`,
                    `wss://${this.baseUrl}:5000`,
                    `wss://${this.baseUrl}:5000/`,
                    `ws://${this.baseUrl}`,
                    `ws://${this.baseUrl}:5000`
                ];

                let results = 'WebSocket Test Results:\n\n';
                
                for (const url of wsUrls) {
                    try {
                        results += `Testing: ${url}\n`;
                        
                        const wsTest = await this.testSingleWebSocket(url);
                        if (wsTest.success) {
                            results += `‚úÖ CONNECTION SUCCESS\n`;
                            results += `Response: ${wsTest.message}\n\n`;
                            
                            if (!this.workingConnection) {
                                this.workingConnection = url;
                                this.enableWorkingConnection();
                            }
                        } else {
                            results += `‚ùå CONNECTION FAILED\n`;
                            results += `Error: ${wsTest.error}\n\n`;
                        }
                    } catch (error) {
                        results += `‚ùå ERROR: ${error.message}\n\n`;
                    }
                    
                    this.updateResult('wsResult', results);
                }
                
                this.updateStatus('wsStatus', 'WebSocket tests completed', 'success');
            }

            testSingleWebSocket(url) {
                return new Promise((resolve) => {
                    const ws = new WebSocket(url);
                    const timeout = setTimeout(() => {
                        ws.close();
                        resolve({ success: false, error: 'Connection timeout' });
                    }, 3000);

                    ws.onopen = () => {
                        clearTimeout(timeout);
                        ws.close();
                        resolve({ success: true, message: 'Connection established' });
                    };

                    ws.onerror = (error) => {
                        clearTimeout(timeout);
                        resolve({ success: false, error: 'Connection failed' });
                    };

                    ws.onclose = (event) => {
                        clearTimeout(timeout);
                        if (event.code === 1000) {
                            resolve({ success: true, message: 'Clean connection' });
                        }
                    };
                });
            }

            async testPorts() {
                this.updateStatus('portStatus', 'Testing different ports...', 'testing');
                this.updateResult('portResult', 'Starting port tests...\n');
                
                const ports = ['', ':3000', ':5000', ':8080', ':80', ':443'];
                let results = 'Port Test Results:\n\n';
                
                for (const port of ports) {
                    const httpUrl = `https://${this.baseUrl}${port}`;
                    const wsUrl = `wss://${this.baseUrl}${port}`;
                    
                    results += `Testing port ${port || 'default'}:\n`;
                    
                    // Test HTTP
                    try {
                        const response = await fetch(httpUrl, { timeout: 3000 });
                        if (response.ok) {
                            results += `  ‚úÖ HTTP: Working\n`;
                            if (!this.workingConnection) {
                                this.workingConnection = `${this.baseUrl}${port}`;
                                this.enableWorkingConnection();
                            }
                        } else {
                            results += `  ‚ùå HTTP: Failed (${response.status})\n`;
                        }
                    } catch (error) {
                        results += `  ‚ùå HTTP: ${error.message}\n`;
                    }
                    
                    // Test WebSocket
                    const wsTest = await this.testSingleWebSocket(wsUrl);
                    if (wsTest.success) {
                        results += `  ‚úÖ WebSocket: Working\n`;
                        if (!this.workingConnection) {
                            this.workingConnection = wsUrl;
                            this.enableWorkingConnection();
                        }
                    } else {
                        results += `  ‚ùå WebSocket: ${wsTest.error}\n`;
                    }
                    
                    results += '\n';
                    this.updateResult('portResult', results);
                }
                
                this.updateStatus('portStatus', 'Port tests completed', 'success');
            }

            enableWorkingConnection() {
                const btn = document.getElementById('useWorkingBtn');
                btn.disabled = false;
                btn.textContent = 'Use Working Connection ‚úÖ';
                
                this.updateResult('workingResult', `Found working connection:\n${this.workingConnection}`);
                this.updateStatus('workingStatus', 'Working connection found!', 'success');
            }

            useWorkingConnection() {
                if (!this.workingConnection) {
                    alert('No working connection found yet. Run tests first!');
                    return;
                }

                const message = `üéâ Working Connection Found!\n\n` +
                    `URL: ${this.workingConnection}\n\n` +
                    `I'll now create a Mini App that uses this working connection.\n\n` +
                    `Click OK to continue.`;
                
                if (this.tg) {
                    this.tg.showAlert(message);
                } else {
                    alert(message);
                }
                
                console.log('‚úÖ Working connection:', this.workingConnection);
            }
        }

        const diagnostic = new BrightSparkDiagnostic();
    </script>
</body>
</html>
